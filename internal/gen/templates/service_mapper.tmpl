// Code generated by lazyent. DO NOT EDIT.
package service

import (
	pb "{{ .ApiPackage }}"
	"{{ .BizPackage }}"
{{- range collectExternalImports .Nodes }}
	"{{ . }}"
{{- end }}
)

{{- range .Nodes }}
{{- $node := . }}

func Biz{{ .Name }}ToProto(b *biz.{{ .Name }}) (*pb.{{ .Name }}, error) {
	if b == nil {
		return nil, nil
	}
{{- range $f := .Fields }}{{ if isFieldProtoExclude $f false }}{{ continue }}{{ end }}
{{- if and (isSlice $f) (not (isSliceTypeMatch $f)) }}
	var {{ camel (protoGoName $f) }} []{{ getGoProtoType $f }}
	for _, item := range b.{{ bizFieldName $f }} {
		{{ camel (protoGoName $f) }} = append({{ camel (protoGoName $f) }}, {{ getGoProtoType $f }}(item))
	}
{{- end }}
{{- end }}
{{- range $e := .Edges }}
{{- if isProtoExclude $e false }}{{ continue }}{{ end }}
{{- if not (isProtoMessage $e false) }}
    {{/* ID List Handling */}}
    {{- if not $e.Unique }}
    var {{ camel (protoStructField $e false) }} []{{ edgeProtoType $e false }}
    for _, item := range b.{{ bizEdgeName $e false }} {
        {{ camel (protoStructField $e false) }} = append({{ camel (protoStructField $e false) }}, item)
    }
    {{- end }}
{{- end }}
{{- end }}
{{- range $e := .Edges }}
{{- if isProtoExclude $e false }}{{ continue }}{{ end }}
{{- if isProtoMessage $e false }}
	{{- if $e.Unique }}
	{{ camel $e.Name }}, err := Biz{{ $e.Type.Name }}ToProto(b.{{ bizEdgeName $e false }})
	if err != nil {
		return nil, err
	}
	{{- else }}
	var {{ camel $e.Name }} []*pb.{{ $e.Type.Name }}
	for _, item := range b.{{ bizEdgeName $e false }} {
		v, err := Biz{{ $e.Type.Name }}ToProto(item)
		if err != nil {
			return nil, err
		}
		{{ camel $e.Name }} = append({{ camel $e.Name }}, v)
	}
	{{- end }}
{{- end }}
{{- end }}
	return &pb.{{ .Name }}{
{{- if .ID }}
		{{ protoGoName .ID }}: {{ convertToProto .ID $node.Name }},
{{- end }}
{{- range $f := .Fields }}
{{- if isFieldProtoExclude $f false }}{{ continue }}{{ end }}
{{- if isSlice $f }}
	{{- if isSliceTypeMatch $f }}
		{{ protoGoName $f }}: b.{{ bizFieldName $f }},
	{{- else }}
		{{ protoGoName $f }}: {{ camel (protoGoName $f) }},
	{{- end }}
{{- else }}
		{{ protoGoName $f }}: {{ convertToProto $f $node.Name }},
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isProtoExclude $e false }}{{ continue }}{{ end }}{{ if not (isProtoMessage $e false) }}
	{{- /* ProtoID */ -}}
    {{- if not $e.Unique }}
        {{ protoStructField $e false }}: {{ camel (protoStructField $e false) }},
    {{- else }}
        {{- if and (edgeHasFK $e) (not (hasField $node.Fields (edgeField $e false))) }}
            {{ protoStructField $e false }}: {{ edgeConvertToProto $e }},
        {{- end }}
    {{- end }}
{{- end }}{{- end }}
{{- range $e := .Edges }}{{ if isProtoExclude $e false }}{{ continue }}{{ end }}{{ if isProtoMessage $e false }}
	{{- if $e.Unique }}
		{{ $e.Name | pascal }}: {{ camel $e.Name }},
	{{- else }}
		{{ $e.Name | pascal }}: {{ camel $e.Name }},
	{{- end }}
{{- end }}{{- end }}
	}, nil
}

func Proto{{ .Name }}ToBiz(p *pb.{{ .Name }}) (*biz.{{ .Name }}, error) {
	if p == nil {
		return nil, nil
	}
{{- range $f := .Fields }}
{{- if isFieldProtoExclude $f false }}{{ continue }}{{ end }}
{{- if requiresErrorCheck $f "ProtoToBiz" }}
	{{ convertFromProtoSetup $f $node.Name }}
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e false }}{{ continue }}{{ end }}{{ if isProtoExclude $e false }}{{ continue }}{{ end }}{{ if not (isProtoMessage $e false) }}
{{- if and (isBizIDOnly $e false) (not $e.Unique) }}
	{{ $targetType := edgeIDType $e }}{{ if eq $targetType "uuid.UUID" }}{{ $targetType = "string" }}{{ end }}
	{{ $protoType := edgeProtoType $e false }}
    var {{ camel (protoStructField $e false) }} []{{ $targetType }}
    for _, item := range p.{{ protoStructField $e false }} {
		{{- if eq $targetType $protoType }}
        {{ camel (protoStructField $e false) }} = append({{ camel (protoStructField $e false) }}, item)
		{{- else }}
        {{ camel (protoStructField $e false) }} = append({{ camel (protoStructField $e false) }}, {{ $targetType }}(item))
		{{- end }}
    }
{{- end }}
{{- if and (isBizPointer $e false) (not (isBizIDOnly $e false)) (not $e.Unique) }}
    var {{ camel (bizEdgeName $e false) }} []*biz.{{ $e.Type.Name }}
    for _, item := range p.{{ protoStructField $e false }} {
        {{ camel (bizEdgeName $e false) }} = append({{ camel (bizEdgeName $e false) }}, {{ edgeConvertFromProto $e false }})
    }
{{- end }}
{{- end }}{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e false }}{{ continue }}{{ end }}{{ if isProtoExclude $e false }}{{ continue }}{{ end }}{{ if isProtoMessage $e false }}
	{{- if $e.Unique }}
	{{ camel (bizEdgeName $e false) }}, err := Proto{{ $e.Type.Name }}ToBiz(p.{{ protoStructField $e false }})
	if err != nil {
		return nil, err
	}
	{{- else }}
	var {{ camel (bizEdgeName $e false) }} []*biz.{{ $e.Type.Name }}
	for _, item := range p.{{ protoStructField $e false }} {
		v, err := Proto{{ $e.Type.Name }}ToBiz(item)
		if err != nil {
			return nil, err
		}
		{{ camel (bizEdgeName $e false) }} = append({{ camel (bizEdgeName $e false) }}, v)
	}
	{{- end }}
{{- end }}{{- end }}
	return &biz.{{ .Name }}{
		{{ .Name }}Base: biz.{{ .Name }}Base{
{{- if .ID }}
			{{ bizFieldName .ID }}: {{ convertFromProto .ID $node.Name }},
{{- end }}
{{- range $f := .Fields }}
{{- if isFieldProtoExclude $f false }}{{ continue }}{{ end }}
{{- if isSlice $f }}
	{{- if isSliceTypeMatch $f }}
			{{ bizFieldName $f }}: p.{{ protoGoName $f }},
	{{- else }}
			{{ bizFieldName $f }}: {{ camel (protoGoName $f) }},
	{{- end }}
{{- else }}
			{{ bizFieldName $f }}: {{ convertFromProtoUsage $f $node.Name }},
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e false }}{{ continue }}{{ end }}{{ if isProtoExclude $e false }}{{ continue }}{{ end }}
{{- if and (edgeHasFK $e) (not (hasField $node.Fields (edgeField $e false))) (not (isProtoMessage $e false)) }}
			{{ edgeField $e false }}: {{ edgeConvertFromProto $e false }}, 
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e false }}{{ continue }}{{ end }}{{ if isProtoExclude $e false }}{{ continue }}{{ end }}{{ if not (isProtoMessage $e false) }}
{{- if and (isBizIDOnly $e false) (not $e.Unique) }}
			{{ bizEdgeName $e false }}: {{ camel (protoStructField $e false) }},
{{- end }}
{{- if and (isBizPointer $e false) (not (isBizIDOnly $e false)) (not $e.Unique) }}
			{{ bizEdgeName $e false }}: {{ camel (bizEdgeName $e false) }},
{{- end }}
{{- end }}{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e false }}{{ continue }}{{ end }}{{ if isProtoExclude $e false }}{{ continue }}{{ end }}{{ if isProtoMessage $e false }}
		{{- if $e.Unique }}
			{{ bizEdgeName $e false }}: {{ camel (bizEdgeName $e false) }},
		{{- else }}
			{{ bizEdgeName $e false }}: {{ camel (bizEdgeName $e false) }},
		{{- end }}
{{- end }}{{- end }}
		},
	}, nil
}

func Proto{{ .Name }}InputToBiz(p *pb.{{ .Name }}Input) (*biz.{{ .Name }}, error) {
	if p == nil {
		return nil, nil
	}
{{- range $f := .Fields }}
{{- if isFieldProtoExclude $f true }}{{ continue }}{{ end }}
{{- if requiresErrorCheck $f "ProtoToBiz" }}
	{{ convertFromProtoSetup $f $node.Name }}
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e true }}{{ continue }}{{ end }}{{ if isProtoExclude $e true }}{{ continue }}{{ end }}{{ if not (isProtoMessage $e true) }}
{{- if and (isBizIDOnly $e true) (not $e.Unique) }}
	{{ $targetType := edgeIDType $e }}{{ if eq $targetType "uuid.UUID" }}{{ $targetType = "string" }}{{ end }}
	{{ $protoType := edgeProtoType $e true }}
    var {{ camel (protoStructField $e true) }} []{{ $targetType }}
    for _, item := range p.{{ protoStructField $e true }} {
		{{- if eq $targetType $protoType }}
        {{ camel (protoStructField $e true) }} = append({{ camel (protoStructField $e true) }}, item)
		{{- else }}
        {{ camel (protoStructField $e true) }} = append({{ camel (protoStructField $e true) }}, {{ $targetType }}(item))
		{{- end }}
    }
{{- end }}
{{- if and (isBizPointer $e true) (not (isBizIDOnly $e true)) (not $e.Unique) }}
    var {{ camel (bizEdgeName $e true) }} []*biz.{{ $e.Type.Name }}
    for _, item := range p.{{ protoStructField $e true }} {
        {{ camel (bizEdgeName $e true) }} = append({{ camel (bizEdgeName $e true) }}, {{ edgeConvertFromProto $e true }})
    }
{{- end }}
{{- end }}{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e true }}{{ continue }}{{ end }}{{ if isProtoExclude $e true }}{{ continue }}{{ end }}{{ if isProtoMessage $e true }}
	{{- if $e.Unique }}
	{{ camel (bizEdgeName $e true) }}, err := Proto{{ $e.Type.Name }}InputToBiz(p.{{ protoStructField $e true }})
	if err != nil {
		return nil, err
	}
	{{- else }}
	var {{ camel (bizEdgeName $e true) }} []*biz.{{ $e.Type.Name }}
	for _, item := range p.{{ protoStructField $e true }} {
		v, err := Proto{{ $e.Type.Name }}InputToBiz(item)
		if err != nil {
			return nil, err
		}
		{{ camel (bizEdgeName $e true) }} = append({{ camel (bizEdgeName $e true) }}, v)
	}
	{{- end }}
{{- end }}{{- end }}
	return &biz.{{ .Name }}{
		{{ .Name }}Base: biz.{{ .Name }}Base{
{{- if .ID }}
			{{ bizFieldName .ID }}: {{ convertFromProto .ID $node.Name }},
{{- end }}
{{- range $f := .Fields }}
{{- if isFieldProtoExclude $f true }}{{ continue }}{{ end }}
{{- if isSlice $f }}
	{{- if isSliceTypeMatch $f }}
			{{ bizFieldName $f }}: p.{{ protoGoName $f }},
	{{- else }}
			{{ bizFieldName $f }}: {{ camel (protoGoName $f) }},
	{{- end }}
{{- else }}
			{{ bizFieldName $f }}: {{ convertFromProtoUsage $f $node.Name }},
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e true }}{{ continue }}{{ end }}{{ if isProtoExclude $e true }}{{ continue }}{{ end }}
{{- if and (edgeHasFK $e) (not (hasField $node.Fields (edgeField $e true))) (not (isProtoMessage $e true)) }}
			{{ edgeField $e true }}: {{ edgeConvertFromProto $e true }}, 
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e true }}{{ continue }}{{ end }}{{ if isProtoExclude $e true }}{{ continue }}{{ end }}{{ if not (isProtoMessage $e true) }}
{{- if and (isBizIDOnly $e true) (not $e.Unique) }}
			{{ bizEdgeName $e true }}: {{ camel (protoStructField $e true) }},
{{- end }}
{{- if and (isBizPointer $e true) (not (isBizIDOnly $e true)) (not $e.Unique) }}
			{{ bizEdgeName $e true }}: {{ camel (bizEdgeName $e true) }},
{{- end }}
{{- end }}{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e true }}{{ continue }}{{ end }}{{ if isProtoExclude $e true }}{{ continue }}{{ end }}{{ if isProtoMessage $e true }}
		{{- if $e.Unique }}
			{{ bizEdgeName $e true }}: {{ camel (bizEdgeName $e true) }},
		{{- else }}
			{{ bizEdgeName $e true }}: {{ camel (bizEdgeName $e true) }},
		{{- end }}
{{- end }}{{- end }}
		},
	}, nil
}
{{- end }}

{{/* Enum Mappers */}}
{{- range $enum := getAllEnums .Nodes }}
func {{ enumToProtoFunc $enum.Field $enum.NodeName }}(e biz.{{ $enum.NodeName }}{{ $enum.Field.StructField }}) pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }} {
	switch e {
	{{- range $pair := getEnumPairs $enum.Field }}
	case biz.{{ $enum.NodeName }}{{ $enum.Field.StructField }}{{ $pair.Key | pascal }}:
		return pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }}_{{ $enum.NodeName | upper }}{{ $enum.Field.StructField | upper }}_{{ $pair.Key }}
	{{- end }}
	default:
		return pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }}_{{ $enum.NodeName | upper }}{{ $enum.Field.StructField | upper }}_UNSPECIFIED
	}
}

func {{ enumFromProtoFunc $enum.Field $enum.NodeName }}(e pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }}) biz.{{ $enum.NodeName }}{{ $enum.Field.StructField }} {
	switch e {
	{{- range $pair := getEnumPairs $enum.Field }}
	case pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }}_{{ $enum.NodeName | upper }}{{ $enum.Field.StructField | upper }}_{{ $pair.Key }}:
		return biz.{{ $enum.NodeName }}{{ $enum.Field.StructField }}{{ $pair.Key | pascal }}
	{{- end }}
	default:
		{{- $default := printf "biz.%s%s(0)" $enum.NodeName $enum.Field.StructField }}
		{{- range $pair := getEnumPairs $enum.Field }}
			{{- if eq $pair.Value 0 }}
				{{- $default = printf "biz.%s%s%s" $enum.NodeName $enum.Field.StructField ($pair.Key | pascal) }}
			{{- end }}
		{{- end }}
		return {{ $default }}
	}
}
{{- end }}
