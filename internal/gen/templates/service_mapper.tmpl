// Code generated by lazyent. DO NOT EDIT.
package service

import (
	pb "{{ .ApiPackage }}"
	"{{ .BizPackage }}"
{{- range collectExternalImports .Nodes }}
	"{{ . }}"
{{- end }}
)

{{- range .Nodes }}
{{- $node := . }}

func Biz{{ .Name }}ToProto(b *biz.{{ .Name }}) (*pb.{{ .Name }}, error) {
	if b == nil {
		return nil, nil
	}
{{- range $f := .Fields }}{{ if isSensitive $f }}{{ continue }}{{ end }}
{{- if and (isSlice $f) (not (isSliceTypeMatch $f)) }}
	var {{ camel (protoGoName $f) }} []{{ getGoProtoType $f }}
	for _, item := range b.{{ bizFieldName $f }} {
		{{ camel (protoGoName $f) }} = append({{ camel (protoGoName $f) }}, {{ getGoProtoType $f }}(item))
	}
{{- end }}
{{- end }}
{{- range $e := .Edges }}
{{- if isProtoExclude $e }}{{ continue }}{{ end }}
{{- if not (isProtoMessage $e) }}
    {{/* ID List Handling */}}
    {{- if not $e.Unique }}
    var {{ camel (protoStructField $e) }} []{{ edgeProtoType $e }}
    for _, item := range b.{{ bizEdgeName $e }} {
        {{ camel (protoStructField $e) }} = append({{ camel (protoStructField $e) }}, item)
    }
    {{- end }}
{{- end }}
{{- end }}
{{- range $e := .Edges }}
{{- if isProtoExclude $e }}{{ continue }}{{ end }}
{{- if isProtoMessage $e }}
	{{- if $e.Unique }}
	{{ camel $e.Name }}, err := Biz{{ $e.Type.Name }}ToProto(b.{{ bizEdgeName $e }})
	if err != nil {
		return nil, err
	}
	{{- else }}
	var {{ camel $e.Name }} []*pb.{{ $e.Type.Name }}
	for _, item := range b.{{ bizEdgeName $e }} {
		v, err := Biz{{ $e.Type.Name }}ToProto(item)
		if err != nil {
			return nil, err
		}
		{{ camel $e.Name }} = append({{ camel $e.Name }}, v)
	}
	{{- end }}
{{- end }}
{{- end }}
	return &pb.{{ .Name }}{
{{- if .ID }}
		{{ protoGoName .ID }}: {{ convertToProto .ID $node.Name }},
{{- end }}
{{- range $f := .Fields }}
{{- if isSensitive $f }}{{ continue }}{{ end }}
{{- if isSlice $f }}
	{{- if isSliceTypeMatch $f }}
		{{ protoGoName $f }}: b.{{ bizFieldName $f }},
	{{- else }}
		{{ protoGoName $f }}: {{ camel (protoGoName $f) }},
	{{- end }}
{{- else }}
		{{ protoGoName $f }}: {{ convertToProto $f $node.Name }},
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isProtoExclude $e }}{{ continue }}{{ end }}{{ if not (isProtoMessage $e) }}
	{{- /* ProtoID */ -}}
    {{- if not $e.Unique }}
        {{ protoStructField $e }}: {{ camel (protoStructField $e) }},
    {{- else }}
        {{- if and (edgeHasFK $e) (not (hasField $node.Fields (edgeField $e))) }}
            {{ protoStructField $e }}: {{ edgeConvertToProto $e }},
        {{- end }}
    {{- end }}
{{- end }}{{- end }}
{{- range $e := .Edges }}{{ if isProtoExclude $e }}{{ continue }}{{ end }}{{ if isProtoMessage $e }}
	{{- if $e.Unique }}
		{{ $e.Name | pascal }}: {{ camel $e.Name }},
	{{- else }}
		{{ $e.Name | pascal }}: {{ camel $e.Name }},
	{{- end }}
{{- end }}{{- end }}
	}, nil
}

func Proto{{ .Name }}ToBiz(p *pb.{{ .Name }}) (*biz.{{ .Name }}, error) {
	if p == nil {
		return nil, nil
	}
{{- range $f := .Fields }}
{{- if isSensitive $f }}{{ continue }}{{ end }}
{{- if requiresErrorCheck $f "ProtoToBiz" }}
	{{ convertFromProtoSetup $f $node.Name }}
{{- end }}
{{- end }}
{{- range $f := .Fields }}
{{- if isSensitive $f }}{{ continue }}{{ end }}
{{- if requiresErrorCheck $f "ProtoToBiz" }}
	{{ convertFromProtoSetup $f $node.Name }}
{{- end }}
{{- end }}
{{- range $f := .Fields }}
{{- if isSensitive $f }}{{ continue }}{{ end }}
{{- if and (isSlice $f) (not (isSliceTypeMatch $f)) }}
	var {{ camel (protoGoName $f) }} []{{ getSliceElementType $f }}
	for _, item := range p.{{ protoGoName $f }} {
        {{- if eq (getSliceElementType $f) "time.Time" }}
             {{ camel (protoGoName $f) }} = append({{ camel (protoGoName $f) }}, item.AsTime())
        {{- else }}
		    {{ camel (protoGoName $f) }} = append({{ camel (protoGoName $f) }}, {{ getSliceElementType $f }}(item))
        {{- end }}
	}
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e }}{{ continue }}{{ end }}{{ if isProtoExclude $e }}{{ continue }}{{ end }}{{ if not (isProtoMessage $e) }}
{{- if and (isBizIDOnly $e) (not $e.Unique) }}
	{{ $targetType := edgeIDType $e }}{{ if eq $targetType "uuid.UUID" }}{{ $targetType = "string" }}{{ end }}
	{{ $protoType := edgeProtoType $e }}
    var {{ camel (protoStructField $e) }} []{{ $targetType }}
    for _, item := range p.{{ protoStructField $e }} {
		{{- if eq $targetType $protoType }}
        {{ camel (protoStructField $e) }} = append({{ camel (protoStructField $e) }}, item)
		{{- else }}
        {{ camel (protoStructField $e) }} = append({{ camel (protoStructField $e) }}, {{ $targetType }}(item))
		{{- end }}
    }
    {{- end }}
{{- end }}{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e }}{{ continue }}{{ end }}{{ if isProtoExclude $e }}{{ continue }}{{ end }}{{ if isProtoMessage $e }}
	{{- if $e.Unique }}
	{{ camel (bizEdgeName $e) }}, err := Proto{{ $e.Type.Name }}ToBiz(p.{{ protoStructField $e }})
	if err != nil {
		return nil, err
	}
	{{- else }}
	var {{ camel (bizEdgeName $e) }} []*biz.{{ $e.Type.Name }}
	for _, item := range p.{{ protoStructField $e }} {
		v, err := Proto{{ $e.Type.Name }}ToBiz(item)
		if err != nil {
			return nil, err
		}
		{{ camel (bizEdgeName $e) }} = append({{ camel (bizEdgeName $e) }}, v)
	}
	{{- end }}
{{- end }}{{- end }}
	return &biz.{{ .Name }}{
		{{ .Name }}Base: biz.{{ .Name }}Base{
{{- if .ID }}
			{{ bizFieldName .ID }}: {{ convertFromProto .ID $node.Name }},
{{- end }}
{{- range $f := .Fields }}
{{- if isSensitive $f }}{{ continue }}{{ end }}
{{- if isSlice $f }}
	{{- if isSliceTypeMatch $f }}
			{{ bizFieldName $f }}: p.{{ protoGoName $f }},
	{{- else }}
			{{ bizFieldName $f }}: {{ camel (protoGoName $f) }},
	{{- end }}
{{- else }}
			{{ bizFieldName $f }}: {{ convertFromProtoUsage $f $node.Name }},
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e }}{{ continue }}{{ end }}{{ if isProtoExclude $e }}{{ continue }}{{ end }}
{{- /* ID Field (always first if mixed?) No used for ToBiz struct init usually unless explicit */ -}}
{{- if and (edgeHasFK $e) (not (hasField $node.Fields (edgeField $e))) (not (isProtoMessage $e)) }}
			{{ edgeField $e }}: {{ edgeConvertFromProto $e }}, 
{{- end }}
{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e }}{{ continue }}{{ end }}{{ if isProtoExclude $e }}{{ continue }}{{ end }}{{ if not (isProtoMessage $e) }}
{{- if and (isBizIDOnly $e) (not $e.Unique) }}
			{{ bizEdgeName $e }}: {{ camel (protoStructField $e) }},
{{- end }}
{{- end }}{{- end }}
{{- range $e := .Edges }}{{ if isBizExclude $e }}{{ continue }}{{ end }}{{ if isProtoExclude $e }}{{ continue }}{{ end }}{{ if isProtoMessage $e }}
{{- /* Relationship Field */ -}}
	{{- if isProtoMessage $e }}
		{{- if $e.Unique }}
			{{ bizEdgeName $e }}: {{ camel (bizEdgeName $e) }},
		{{- else }}
			{{ bizEdgeName $e }}: {{ camel (bizEdgeName $e) }},
		{{- end }}
	{{- end }}
{{- end }}{{- end }}
		},
	}, nil
}
{{- end }}

{{/* Enum Mappers */}}
{{- range $enum := getAllEnums .Nodes }}
func {{ enumToProtoFunc $enum.Field $enum.NodeName }}(e biz.{{ $enum.NodeName }}{{ $enum.Field.StructField }}) pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }} {
	switch e {
	{{- range $pair := getEnumPairs $enum.Field }}
	case biz.{{ $enum.NodeName }}{{ $enum.Field.StructField }}{{ $pair.Key | pascal }}:
		return pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }}_{{ $enum.NodeName | upper }}{{ $enum.Field.StructField | upper }}_{{ $pair.Key }}
	{{- end }}
	default:
		return pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }}_{{ $enum.NodeName | upper }}{{ $enum.Field.StructField | upper }}_UNSPECIFIED
	}
}

func {{ enumFromProtoFunc $enum.Field $enum.NodeName }}(e pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }}) biz.{{ $enum.NodeName }}{{ $enum.Field.StructField }} {
	switch e {
	{{- range $pair := getEnumPairs $enum.Field }}
	case pb.{{ $enum.NodeName }}{{ $enum.Field.StructField }}_{{ $enum.NodeName | upper }}{{ $enum.Field.StructField | upper }}_{{ $pair.Key }}:
		return biz.{{ $enum.NodeName }}{{ $enum.Field.StructField }}{{ $pair.Key | pascal }}
	{{- end }}
	default:
		{{- $default := printf "biz.%s%s(0)" $enum.NodeName $enum.Field.StructField }}
		{{- range $pair := getEnumPairs $enum.Field }}
			{{- if eq $pair.Value 0 }}
				{{- $default = printf "biz.%s%s%s" $enum.NodeName $enum.Field.StructField ($pair.Key | pascal) }}
			{{- end }}
		{{- end }}
		return {{ $default }}
	}
}
{{- end }}
