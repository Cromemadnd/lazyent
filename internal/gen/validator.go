package gen

import (
	"fmt"
	"strings"

	entgen "entgo.io/ent/entc/gen"
	types "github.com/Cromemadnd/lazyent/internal/types"
)

func getValidateRules(f *entgen.Field, nodeName string, validatorType types.ProtoValidator) string {
	if validatorType == types.ProtoValidatorNoValidator {
		return ""
	}

	// Get Annotation
	a := getFieldAnnotation(f)
	var rules *types.ValidationRules

	// 1. Initialize from Struct Annotation if present
	if a != nil && a.Validation != nil {
		rules = a.Validation
	} else {
		rules = &types.ValidationRules{}
	}

	// 2. Apply Defaults
	// Enum
	if f.IsEnum() && !isExternalEnum(f) {
		if rules.Enum == nil {
			rules.Enum = &types.EnumRules{}
		}
		// Enforce DefinedOnly by default for Enums generated by Ent
		rules.Enum.DefinedOnly = true
	}

	// UUID
	if f.Type.String() == "uuid.UUID" {
		if rules.String == nil {
			rules.String = &types.StringRules{}
		}
		rules.String.UUID = true
	}

	pType := getProtoType(f)

	// 3. Render if Logic exists
	if !isValidationEmpty(rules) {
		return renderValidationRules(rules, validatorType, pType)
	}

	// 4. Fallback to Legacy String (Only if no structured rules applied)
	if a != nil && a.ProtoValidation != "" {
		val := a.ProtoValidation
		// Basic formatting fix
		val = strings.ReplaceAll(val, ":", ": ")
		val = strings.ReplaceAll(val, ",", ", ")
		val = strings.ReplaceAll(val, ":  ", ": ")
		val = strings.ReplaceAll(val, ",  ", ", ")

		if validatorType == types.ProtoValidatorProtoValidate {
			// Convert PGV syntax to ProtoValidate syntax (simple heuristic)
			// Remove leading dot if present for top level options
			if strings.HasPrefix(val, ".") {
				val = strings.TrimPrefix(val, ".")
			}
		}

		if strings.HasPrefix(val, ".") {
			return val
		}

		if strings.HasPrefix(val, "repeated") {
			if strings.Contains(val, "items:") || strings.Contains(val, "items :") {
				return fmt.Sprintf(".repeated = { %s }", val)
			}
		}

		return fmt.Sprintf(".%s = { %s }", pType, val)
	}

	return ""
}

func isValidationEmpty(v *types.ValidationRules) bool {
	if v == nil {
		return true
	}
	return v.String == nil && v.Number == nil && v.Repeated == nil && v.Enum == nil
}

func renderValidationRules(v *types.ValidationRules, validatorType types.ProtoValidator, protoType string) string {
	var parts []string
	if v.String != nil {
		parts = append(parts, renderStringRules(v.String, validatorType))
	}
	if v.Number != nil {
		parts = append(parts, renderNumberRules(v.Number, validatorType, protoType))
	}
	if v.Repeated != nil {
		parts = append(parts, renderRepeatedRules(v.Repeated, validatorType))
	}
	if v.Enum != nil {
		parts = append(parts, renderEnumRules(v.Enum, validatorType))
	}

	ruleBody := strings.Join(parts, ", ")
	if ruleBody == "" {
		return ""
	}

	// PGV vs ProtoValidate wrapping
	// Simple rule: we return the content "string: { ... }, int32: { ... }" formatted properly
	// Wait, we need to know the type?
	// No, ValidationRules Struct is type-specific (StringRules -> string: {...})

	// Implementation Detail: renderStringRules returns "string: { uuid: true }" or ".string.uuid = true"?
	// Let's return the inner content relative to root?
	// PGV: (validate.rules).string.uuid = true  OR (validate.rules) = { string: { uuid: true } }
	// ProtoValidate: (buf.validate.field).string.uuid = true OR (buf.validate.field).string = { uuid: true }

	// Let's generate flat syntax if simple, or nested if complex?
	// Nested is easier to generate programmatically.
	// e.g. .string = { uuid: true, min_len: 5 }

	// Special handling for legacy/mix?
	// If returned parts have keys like "string", "int32", we join them.
	// But usually only one type rule applies per field.

	// PGV Style: .string = { ... }
	// Buf Style: (buf.validate.field).string = { ... }

	// PGV is the base generated by helper functions (e.g. .string = {})

	// PGV Style: .string = { ... }
	// Buf Style: (buf.validate.field).string = { ... }

	// PGV is the base generated by helper functions (e.g. .string = {})

	if validatorType == types.ProtoValidatorProtoValidate {
		// Buf uses (buf.validate.field) prefix and NO dot for the type rule if using option syntax
		// But helpers return ".string = {}"

		// Remove leading dot
		ruleBody = strings.TrimPrefix(ruleBody, ".")
		return fmt.Sprintf("(buf.validate.field).%s", ruleBody)
	}

	return ruleBody
}

func renderStringRules(r *types.StringRules, vt types.ProtoValidator) string {
	var rules []string

	if r.Const != nil {
		rules = append(rules, fmt.Sprintf("const: %q", *r.Const))
	}
	if r.Len != nil {
		rules = append(rules, fmt.Sprintf("len: %d", *r.Len))
	}
	if r.MinLen != nil {
		rules = append(rules, fmt.Sprintf("min_len: %d", *r.MinLen))
	}
	if r.MaxLen != nil {
		rules = append(rules, fmt.Sprintf("max_len: %d", *r.MaxLen))
	}
	if r.LenBytes != nil {
		rules = append(rules, fmt.Sprintf("len_bytes: %d", *r.LenBytes))
	}
	if r.Pattern != nil {
		rules = append(rules, fmt.Sprintf("pattern: %q", *r.Pattern))
	}
	if r.Prefix != nil {
		rules = append(rules, fmt.Sprintf("prefix: %q", *r.Prefix))
	}
	if r.Suffix != nil {
		rules = append(rules, fmt.Sprintf("suffix: %q", *r.Suffix))
	}
	if r.Contains != nil {
		rules = append(rules, fmt.Sprintf("contains: %q", *r.Contains))
	}
	if len(r.In) > 0 {
		// quoted strings
		var q []string
		for _, s := range r.In {
			q = append(q, fmt.Sprintf("%q", s))
		}
		rules = append(rules, fmt.Sprintf("in: [%s]", strings.Join(q, ", ")))
	}
	if len(r.NotIn) > 0 {
		var q []string
		for _, s := range r.NotIn {
			q = append(q, fmt.Sprintf("%q", s))
		}
		rules = append(rules, fmt.Sprintf("not_in: [%s]", strings.Join(q, ", ")))
	}
	if r.Email {
		rules = append(rules, "email: true")
	}
	if r.Hostname {
		rules = append(rules, "hostname: true")
	}
	if r.IP {
		rules = append(rules, "ip: true")
	}
	if r.IPV4 {
		rules = append(rules, "ipv4: true")
	}
	if r.IPV6 {
		rules = append(rules, "ipv6: true")
	}
	if r.URI {
		rules = append(rules, "uri: true")
	}
	if r.URIRef {
		rules = append(rules, "uri_ref: true")
	}
	if r.Address {
		rules = append(rules, "address: true")
	}
	if r.UUID {
		rules = append(rules, "uuid: true")
	}
	if r.IgnoreEmpty {
		rules = append(rules, "ignore_empty: true")
	}

	if len(rules) == 0 {
		return ""
	}
	return fmt.Sprintf(".string = { %s }", strings.Join(rules, ", "))
}

func renderNumberRules(r *types.NumberRules, vt types.ProtoValidator, protoType string) string {
	var rules []string

	// Determine format verb based on protoType
	// int32, int64, uint32, uint64 -> %d (or without .0)
	// float, double -> %v or %f

	isFloat := protoType == "float" || protoType == "double"
	fmtVal := func(v float64) string {
		if isFloat {
			return fmt.Sprintf("%f", v)
		}
		return fmt.Sprintf("%d", int64(v))
	}

	if r.Const != nil {
		rules = append(rules, fmt.Sprintf("const: %s", fmtVal(*r.Const)))
	}
	if r.LT != nil {
		rules = append(rules, fmt.Sprintf("lt: %s", fmtVal(*r.LT)))
	}
	if r.LTE != nil {
		rules = append(rules, fmt.Sprintf("lte: %s", fmtVal(*r.LTE)))
	}
	if r.GT != nil {
		rules = append(rules, fmt.Sprintf("gt: %s", fmtVal(*r.GT)))
	}
	if r.GTE != nil {
		rules = append(rules, fmt.Sprintf("gte: %s", fmtVal(*r.GTE)))
	}

	if len(r.In) > 0 {
		var q []string
		for _, s := range r.In {
			q = append(q, fmtVal(s))
		}
		rules = append(rules, fmt.Sprintf("in: [%s]", strings.Join(q, ", ")))
	}
	if len(r.NotIn) > 0 {
		var q []string
		for _, s := range r.NotIn {
			q = append(q, fmtVal(s))
		}
		rules = append(rules, fmt.Sprintf("not_in: [%s]", strings.Join(q, ", ")))
	}
	if r.IgnoreEmpty {
		rules = append(rules, "ignore_empty: true")
	}

	if len(rules) == 0 {
		return ""
	}
	return fmt.Sprintf(".%s = { %s }", protoType, strings.Join(rules, ", "))
}

func renderRepeatedRules(r *types.RepeatedRules, vt types.ProtoValidator) string {
	var rules []string
	if r.Len != nil {
		rules = append(rules, fmt.Sprintf("len: %d", *r.Len))
	}
	if r.MinItems != nil {
		rules = append(rules, fmt.Sprintf("min_items: %d", *r.MinItems))
	}
	if r.MaxItems != nil {
		rules = append(rules, fmt.Sprintf("max_items: %d", *r.MaxItems))
	}
	if r.Unique {
		rules = append(rules, "unique: true")
	}
	if r.IgnoreEmpty {
		rules = append(rules, "ignore_empty: true")
	}

	if len(rules) == 0 {
		return ""
	}
	return fmt.Sprintf(".repeated = { %s }", strings.Join(rules, ", "))
}

func renderEnumRules(r *types.EnumRules, vt types.ProtoValidator) string {
	var rules []string
	if r.Const != nil {
		rules = append(rules, fmt.Sprintf("const: %d", *r.Const))
	}
	if r.DefinedOnly {
		rules = append(rules, "defined_only: true")
	}
	if len(r.In) > 0 {
		var q []string
		for _, s := range r.In {
			q = append(q, fmt.Sprintf("%d", s))
		}
		rules = append(rules, fmt.Sprintf("in: [%s]", strings.Join(q, ", ")))
	}
	if len(r.NotIn) > 0 {
		var q []string
		for _, s := range r.NotIn {
			q = append(q, fmt.Sprintf("%d", s))
		}
		rules = append(rules, fmt.Sprintf("not_in: [%s]", strings.Join(q, ", ")))
	}

	if len(rules) == 0 {
		return ""
	}
	return fmt.Sprintf(".enum = { %s }", strings.Join(rules, ", "))
}
