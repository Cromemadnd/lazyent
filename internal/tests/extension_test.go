package tests

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
	"github.com/Cromemadnd/lazyent"
	"github.com/google/go-cmp/cmp"
)

func TestLazyEntIntegration(t *testing.T) {
	wd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get working directory: %v", err)
	}

	// 1. Setup paths based on test environment
	// The test environment is located at internal/tests/testenv
	// The entc.go is located at internal/tests/testenv/app/user/internal/data/ent/entc.go
	// We need to run ent code generation from that directory or execute the logic equivalent to it.

	testEnvRoot := filepath.Join(wd, "testenv")
	entGenDir := filepath.Join(testEnvRoot, "app/user/internal/data/ent")

	// 2. Change to entGenDir to run generation
	// This simulates running `go generate` inside that directory
	if err := os.Chdir(entGenDir); err != nil {
		t.Fatalf("failed to chdir to ent gen dir: %v", err)
	}
	defer func() {
		// Restore WD
		if err := os.Chdir(wd); err != nil {
			t.Fatalf("failed to restore working directory: %v", err)
		}
	}()

	// 3. Define Config (matching entc.go logic logic but programmatic)
	// NOTICE: Path resolution in Config.ProtoOut etc is relative to Project Root (Generator execution context) usually?
	// But in entc.go user set paths relative to MODULE ROOT (e.g. tests/testenv/...).
	// The generator uses `internal/tests/entc.go`'s config.
	// Let's invoke the generation logic directly here mirroring `entc.go`.

	// NOTE: The paths in Config must be relative to the module root because `lazyent` generator joins them with `moduleRoot`.
	// But here we are running test inside `internal/tests`.
	// `entc.go` used "tests/testenv/..." which suggests it expects to run from module root?
	// Wait, `entc.go` has `entc.Generate("./schema", ...)` which implies CWD is `.../ent`.
	// If `lazyent` joins `moduleRoot` + `ConfigPath`, and `moduleRoot` is `os.Getwd()` (which is `.../ent`),
	// then we need to set paths relative to `.../ent`?
	// NO. `lazyent` generator does `moduleRoot, _ := os.Getwd()`.
	// IF we run from `.../ent` directory, `moduleRoot` will be `.../ent`.
	// So `Config.ProtoOut` should be relative to `.../ent`.
	// But `entc.go` uses `tests/testenv/...` which looks like path from actual project root `lazyent/`.
	// This implies `entc.go` might be intended to run from `lazyent/` root?
	// But `entc.Generate("./schema")` implies schema is in `./schema`.
	// In `testenv/app/user/internal/data/ent`, there IS a `schema` dir.
	// So `entc.go` MUST run from `.../ent`.
	// THUS, `lazyent` generator's `os.Getwd()` will return `.../ent`.
	// AND `Config.ProtoOut` = `tests/testenv/...` will be appended.
	// Result: `.../ent/tests/testenv/...`. This is WRONG. It duplicates path segments.
	// UNLESS using absolute paths or `..`.

	// FIX: We should use `../../../../../../api/v1` style relative paths from `ent` dir?
	// OR `lazyent` generator should detect project root?
	// Current `generator.go`: `filepath.Join(moduleRoot, ...)`
	// If user runs `go generate ./...` from root, `os.Getwd()` is root.
	// If user runs `go generate` inside `ent`, `os.Getwd()` is `ent`.
	// The `entc.go` provided by user uses `tests/testenv/api/v1`.
	// This implies the user EXPECTS `moduleRoot` to be the PROJECT ROOT `e:\lazyent`.
	// But `entc.Generate("./schema")` runs from `ent`.
	// This is a common conflict.
	// Let's assume for this TEST, we want to match `entc.go`.
	// We will run code generation.

	// We need to make sure we are at Module Root `e:\lazyent` for `lazyent` extension to resolve paths correctly if it assumes root.
	// BUT `entc.Generate("./schema")` requires us to be near `schema`.
	// Conflict: `schema` is deep inside.

	projectRoot := filepath.Join(wd, "../..")

	// LET'S assume we just run what's in `entc.go` effectively.

	// 3. Define Config
	// We run from entGenDir, so paths are relative to it.
	// entGenDir: internal/tests/testenv/app/user/internal/data/ent

	conf := lazyent.Config{
		ProtoOut:     "internal/tests/testenv/api/v1",
		ProtoPackage: "user.v1",
		GoPackage:    "lazyent-test-app/user/v1;v1",
		BizOut:       "internal/tests/testenv/app/user/internal/biz",
		ServiceOut:   "internal/tests/testenv/app/user/internal/service",
		DataOut:      "internal/tests/testenv/app/user/internal/data",
		SingleFile:   true,
	}

	schemaPath := "./schema"
	targetPath := "." // Target is current dir (ent)

	opts := []entc.Option{
		entc.Extensions(lazyent.NewExtension(conf)),
	}

	config := &gen.Config{
		Target:  targetPath,
		Package: "github.com/Cromemadnd/lazyent/internal/tests/testenv/app/user/internal/data/ent",
		Schema:  schemaPath,
		Header:  "// Code generated by ent, DO NOT EDIT.",
	}

	if err := entc.Generate(schemaPath, config, opts...); err != nil {
		t.Fatalf("Generation failed: %v", err)
	}

	// 4. Verify Outputs against Golden files
	// Files are in projectRoot/tests/testenv/...

	filesToCheck := map[string]string{
		"internal/tests/testenv/api/v1/dtos_gen.proto":                            "dtos_gen.proto.golden",
		"internal/tests/testenv/app/user/internal/biz/entities_base_gen.go":       "entities_base_gen.go.golden",
		"internal/tests/testenv/app/user/internal/service/service_mappers_gen.go": "service_mappers_gen.go.golden",
		"internal/tests/testenv/app/user/internal/data/data_mappers_gen.go":       "data_mappers_gen.go.golden",
	}

	for genRelPath := range filesToCheck {
		fullGenPath := filepath.Join(projectRoot, genRelPath)
		// Golden file is next to generated file? No, it's .golden extension.
		// User provided golden files in `testenv`.
		// e.g. `dtos_gen.proto.golden` is in `api/v1/`.
		// So goldenPath is fullGenPath + ".golden"

		fullGoldenPath := fullGenPath + ".golden"

		if _, err := os.Stat(fullGenPath); os.IsNotExist(err) {
			t.Errorf("Expected file %s was not generated", fullGenPath)
			continue
		}

		genContent, err := os.ReadFile(fullGenPath)
		if err != nil {
			t.Fatalf("Failed to read generated file: %v", err)
		}

		goldenContent, err := os.ReadFile(fullGoldenPath)
		if err != nil {
			t.Logf("Golden file %s missing. Saving generated content.", fullGoldenPath)
			if err := os.WriteFile(fullGoldenPath, genContent, 0644); err != nil {
				t.Errorf("Failed to write golden file: %v", err)
			}
			continue
		}

		// Normalize line endings and trim space
		// Normalize line endings
		genStr := strings.ReplaceAll(string(genContent), "\r\n", "\n")
		goldenStr := strings.ReplaceAll(string(goldenContent), "\r\n", "\n")

		// Function to remove blank lines
		removeBlankLines := func(s string) string {
			var lines []string
			for _, line := range strings.Split(s, "\n") {
				if strings.TrimSpace(line) != "" {
					lines = append(lines, line)
				}
			}
			return strings.Join(lines, "\n")
		}

		genNormalized := removeBlankLines(genStr)
		goldenNormalized := removeBlankLines(goldenStr)

		if diff := cmp.Diff(goldenNormalized, genNormalized); diff != "" {
			t.Errorf("%s mismatch (-want +got):\n%s", filepath.Base(genRelPath), diff)
		}
	}
}
