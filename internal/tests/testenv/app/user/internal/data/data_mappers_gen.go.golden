// Code generated by lazyent. DO NOT EDIT.
package data

import (
	"fmt"
	"time"

	"github.com/Cromemadnd/lazyent/internal/tests/testenv/app/user/internal/biz"
	"github.com/Cromemadnd/lazyent/internal/tests/testenv/app/user/internal/data/ent"
	"github.com/Cromemadnd/lazyent/internal/tests/testenv/app/user/internal/data/ent/user"
	"github.com/google/uuid"
)

func EntGroupToBiz(e *ent.Group) (*biz.Group, error) {
	if e == nil {
		return nil, nil
	}
	var usersTest []*biz.User
	for _, item := range e.Edges.Users {
		v, err := EntUserToBiz(item)
		if err != nil {
			return nil, err
		}
		usersTest = append(usersTest, v)
	}
	return &biz.Group{
		GroupBase: biz.GroupBase{
			UUID:      e.ID.String(),
			CreatedAt: e.CreatedAt,
			UpdatedAt: e.UpdatedAt,
			Name:      e.Name,
			UsersTest: usersTest,
		},
	}, nil
}

func BizGroupToEnt(b *biz.Group) (*ent.Group, error) {
	if b == nil {
		return nil, nil
	}
	var users []*ent.User
	for _, item := range b.UsersTest {
		v, err := BizUserToEnt(item)
		if err != nil {
			return nil, err
		}
		users = append(users, v)
	}
	var iDEntVal uuid.UUID
	if b.UUID != "" {
		val, err := uuid.Parse(b.UUID)
		if err != nil {
			return nil, fmt.Errorf("invalid UUID for id: %w", err)
		}
		iDEntVal = val
	}
	return &ent.Group{
		ID:        iDEntVal,
		CreatedAt: b.CreatedAt,
		UpdatedAt: b.UpdatedAt,
		Name:      b.Name,
		Edges: ent.GroupEdges{
			Users: users,
		},
	}, nil
}

func EntPostToBiz(e *ent.Post) (*biz.Post, error) {
	if e == nil {
		return nil, nil
	}
	author, err := EntUserToBiz(e.Edges.Author)
	if err != nil {
		return nil, err
	}
	var coAuthors []*biz.User
	for _, item := range e.Edges.CoAuthors {
		v, err := EntUserToBiz(item)
		if err != nil {
			return nil, err
		}
		coAuthors = append(coAuthors, v)
	}
	var relevantGroupsID []string
	for _, item := range e.Edges.RelevantGroups {
		relevantGroupsID = append(relevantGroupsID, item.ID.String())
	}
	var followers []*biz.User
	for _, item := range e.Edges.Followers {
		v, err := EntUserToBiz(item)
		if err != nil {
			return nil, err
		}
		followers = append(followers, v)
	}
	var coAuthorsArchive []*biz.User
	for _, item := range e.Edges.CoAuthorsArchive {
		v, err := EntUserToBiz(item)
		if err != nil {
			return nil, err
		}
		coAuthorsArchive = append(coAuthorsArchive, v)
	}
	return &biz.Post{
		PostBase: biz.PostBase{
			UUID:             e.ID.String(),
			CreatedAt:        e.CreatedAt,
			UpdatedAt:        e.UpdatedAt,
			Title:            e.Title,
			Content:          e.Content,
			Slug:             e.Slug,
			ManagementKey:    e.ManagementKey,
			Summary:          e.Summary,
			Author:           author,
			CoAuthors:        coAuthors,
			RelevantGroupsID: relevantGroupsID,
			Followers:        followers,
			CoAuthorsArchive: coAuthorsArchive,
		},
	}, nil
}

func BizPostToEnt(b *biz.Post) (*ent.Post, error) {
	if b == nil {
		return nil, nil
	}
	author, err := BizUserToEnt(b.Author)
	if err != nil {
		return nil, err
	}
	var coAuthors []*ent.User
	for _, item := range b.CoAuthors {
		v, err := BizUserToEnt(item)
		if err != nil {
			return nil, err
		}
		coAuthors = append(coAuthors, v)
	}
	var relevantGroups []*ent.Group
	for _, item := range b.RelevantGroupsID {
		val, err := uuid.Parse(item)
		if err != nil {
			return nil, err
		}
		relevantGroups = append(relevantGroups, &ent.Group{
			ID: val,
		})
	}
	var followers []*ent.User
	for _, item := range b.Followers {
		v, err := BizUserToEnt(item)
		if err != nil {
			return nil, err
		}
		followers = append(followers, v)
	}
	var coAuthorsArchive []*ent.User
	for _, item := range b.CoAuthorsArchive {
		v, err := BizUserToEnt(item)
		if err != nil {
			return nil, err
		}
		coAuthorsArchive = append(coAuthorsArchive, v)
	}
	var iDEntVal uuid.UUID
	if b.UUID != "" {
		val, err := uuid.Parse(b.UUID)
		if err != nil {
			return nil, fmt.Errorf("invalid UUID for id: %w", err)
		}
		iDEntVal = val
	}
	return &ent.Post{
		ID:            iDEntVal,
		CreatedAt:     b.CreatedAt,
		UpdatedAt:     b.UpdatedAt,
		Title:         b.Title,
		Content:       b.Content,
		Slug:          b.Slug,
		ManagementKey: b.ManagementKey,
		Summary:       b.Summary,
		Edges: ent.PostEdges{
			Author:           author,
			CoAuthors:        coAuthors,
			RelevantGroups:   relevantGroups,
			Followers:        followers,
			CoAuthorsArchive: coAuthorsArchive,
		},
	}, nil
}

func EntUserToBiz(e *ent.User) (*biz.User, error) {
	if e == nil {
		return nil, nil
	}
	var postIDs []string
	for _, item := range e.Edges.Posts {
		postIDs = append(postIDs, item.ID.String())
	}
	var groups []*biz.Group
	for _, item := range e.Edges.Groups {
		v, err := EntGroupToBiz(item)
		if err != nil {
			return nil, err
		}
		groups = append(groups, v)
	}
	var followers []*biz.User
	for _, item := range e.Edges.Followers {
		v, err := EntUserToBiz(item)
		if err != nil {
			return nil, err
		}
		followers = append(followers, v)
	}
	var coAuthorsArchive []*biz.User
	for _, item := range e.Edges.CoAuthorsArchive {
		v, err := EntUserToBiz(item)
		if err != nil {
			return nil, err
		}
		coAuthorsArchive = append(coAuthorsArchive, v)
	}
	var friends []*biz.User
	for _, item := range e.Edges.Friends {
		v, err := EntUserToBiz(item)
		if err != nil {
			return nil, err
		}
		friends = append(friends, v)
	}
	return &biz.User{
		UserBase: biz.UserBase{
			UUID:       e.ID.String(),
			CreatedAt:  e.CreatedAt,
			UpdatedAt:  e.UpdatedAt,
			Name:       e.Name,
			Age:        e.Age,
			Nickname:   e.Nickname,
			UserScore:  uint8(e.Score),
			IsVerified: e.IsVerified,
			Tags:       e.Tags,
			Password:   e.Password,
			TestUUID:   e.TestUUID.String(),
			TestNillableUUID: func() string {
				if e.TestNillableUUID != nil {
					return e.TestNillableUUID.String()
				}
				return ""
			}(),
			Status:           EntUserStatusToBiz(e.Status),
			Role:             e.Role,
			TestTime:         time.Time(e.TestTime),
			LastLoginIP:      e.LastLoginIP,
			VerificationCode: e.VerificationCode,
			PostIDs:          postIDs,
			Groups:           groups,
			Followers:        followers,
			CoAuthorsArchive: coAuthorsArchive,
			Friends:          friends,
		},
	}, nil
}

func BizUserToEnt(b *biz.User) (*ent.User, error) {
	if b == nil {
		return nil, nil
	}
	var posts []*ent.Post
	for _, item := range b.PostIDs {
		val, err := uuid.Parse(item)
		if err != nil {
			return nil, err
		}
		posts = append(posts, &ent.Post{
			ID: val,
		})
	}
	var groups []*ent.Group
	for _, item := range b.Groups {
		v, err := BizGroupToEnt(item)
		if err != nil {
			return nil, err
		}
		groups = append(groups, v)
	}
	var followers []*ent.User
	for _, item := range b.Followers {
		v, err := BizUserToEnt(item)
		if err != nil {
			return nil, err
		}
		followers = append(followers, v)
	}
	var coAuthorsArchive []*ent.User
	for _, item := range b.CoAuthorsArchive {
		v, err := BizUserToEnt(item)
		if err != nil {
			return nil, err
		}
		coAuthorsArchive = append(coAuthorsArchive, v)
	}
	var friends []*ent.User
	for _, item := range b.Friends {
		v, err := BizUserToEnt(item)
		if err != nil {
			return nil, err
		}
		friends = append(friends, v)
	}
	var iDEntVal uuid.UUID
	if b.UUID != "" {
		val, err := uuid.Parse(b.UUID)
		if err != nil {
			return nil, fmt.Errorf("invalid UUID for id: %w", err)
		}
		iDEntVal = val
	}
	var testUUIDEntVal uuid.UUID
	if b.TestUUID != "" {
		val, err := uuid.Parse(b.TestUUID)
		if err != nil {
			return nil, fmt.Errorf("invalid UUID for test_uuid: %w", err)
		}
		testUUIDEntVal = val
	}
	var testNillableUUIDEntVal *uuid.UUID
	if b.TestNillableUUID != "" {
		parsed, err := uuid.Parse(b.TestNillableUUID)
		if err != nil {
			return nil, fmt.Errorf("invalid UUID for test_nillable_uuid: %w", err)
		}
		testNillableUUIDEntVal = &parsed
	}
	return &ent.User{
		ID:               iDEntVal,
		CreatedAt:        b.CreatedAt,
		UpdatedAt:        b.UpdatedAt,
		Name:             b.Name,
		Age:              b.Age,
		Nickname:         b.Nickname,
		Score:            int(b.UserScore),
		IsVerified:       b.IsVerified,
		Tags:             b.Tags,
		Password:         b.Password,
		TestUUID:         testUUIDEntVal,
		TestNillableUUID: testNillableUUIDEntVal,
		Status:           BizUserStatusToEnt(b.Status),
		Role:             b.Role,
		TestTime:         time.Time(b.TestTime),
		LastLoginIP:      b.LastLoginIP,
		VerificationCode: b.VerificationCode,
		Edges: ent.UserEdges{
			Posts:            posts,
			Groups:           groups,
			Followers:        followers,
			CoAuthorsArchive: coAuthorsArchive,
			Friends:          friends,
		},
	}, nil
}

func EntUserStatusToBiz(v user.Status) biz.UserStatus {
	switch v {
	case user.StatusUNSPECIFIED:
		return biz.UserStatusUnspecified
	case user.StatusACTIVE:
		return biz.UserStatusActive
	case user.StatusINACTIVE:
		return biz.UserStatusInactive
	case user.StatusBANNED:
		return biz.UserStatusBanned
	default:
		return 0
	}
}

func BizUserStatusToEnt(v biz.UserStatus) user.Status {
	switch v {
	case biz.UserStatusUnspecified:
		return user.StatusUNSPECIFIED
	case biz.UserStatusActive:
		return user.StatusACTIVE
	case biz.UserStatusInactive:
		return user.StatusINACTIVE
	case biz.UserStatusBanned:
		return user.StatusBANNED
	default:
		return ""
	}
}
