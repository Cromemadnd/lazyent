// Code generated by lazyent. DO NOT EDIT.
package service

import (
	"time"

	pb "github.com/Cromemadnd/lazyent/internal/tests/testenv/api/v1"
	"github.com/Cromemadnd/lazyent/internal/tests/testenv/app/user/internal/biz"
	"github.com/Cromemadnd/lazyent/internal/tests/testenv/pkg/auth"
	"google.golang.org/protobuf/types/known/timestamppb"
)

func BizGroupToProto(b *biz.Group) (*pb.Group, error) {
	if b == nil {
		return nil, nil
	}
	var users []*pb.User
	for _, item := range b.UsersTest {
		v, err := BizUserToProto(item)
		if err != nil {
			return nil, err
		}
		users = append(users, v)
	}
	return &pb.Group{
		Uuid:      b.UUID,
		CreatedAt: timestamppb.New(b.CreatedAt),
		UpdatedAt: timestamppb.New(b.UpdatedAt),
		Name:      b.Name,
		Users:     users,
	}, nil
}

func ProtoGroupToBiz(p *pb.Group) (*biz.Group, error) {
	if p == nil {
		return nil, nil
	}
	var usersTest []*biz.User
	for _, item := range p.UsersTest {
		v, err := ProtoUserToBiz(item)
		if err != nil {
			return nil, err
		}
		usersTest = append(usersTest, v)
	}
	return &biz.Group{
		GroupBase: biz.GroupBase{
			UUID:      p.Uuid,
			CreatedAt: p.CreatedAt.AsTime(),
			UpdatedAt: p.UpdatedAt.AsTime(),
			Name:      p.Name,
			UsersTest: usersTest,
		},
	}, nil
}

func ProtoGroupInputToBiz(p *pb.GroupInput) (*biz.Group, error) {
	if p == nil {
		return nil, nil
	}
	var usersTest []*biz.User
	for _, item := range p.UsersTest {
		v, err := ProtoUserInputToBiz(item)
		if err != nil {
			return nil, err
		}
		usersTest = append(usersTest, v)
	}
	return &biz.Group{
		GroupBase: biz.GroupBase{
			UUID:      p.Uuid,
			CreatedAt: p.CreatedAt.AsTime(),
			UpdatedAt: p.UpdatedAt.AsTime(),
			Name:      p.Name,
			UsersTest: usersTest,
		},
	}, nil
}

func BizPostToProto(b *biz.Post) (*pb.Post, error) {
	if b == nil {
		return nil, nil
	}

	var relevantGroupsID []string
	for _, item := range b.RelevantGroupsID {
		relevantGroupsID = append(relevantGroupsID, item)
	}

	var followersID []string
	for _, item := range b.Followers {
		followersID = append(followersID, item.UUID)
	}

	var coAuthorsArchiveID []string
	for _, item := range b.CoAuthorsArchive {
		coAuthorsArchiveID = append(coAuthorsArchiveID, item.UUID)
	}
	author, err := BizUserToProto(b.Author)
	if err != nil {
		return nil, err
	}
	var co_authors []*pb.User
	for _, item := range b.CoAuthors {
		v, err := BizUserToProto(item)
		if err != nil {
			return nil, err
		}
		co_authors = append(co_authors, v)
	}
	return &pb.Post{
		Uuid:               b.UUID,
		CreatedAt:          timestamppb.New(b.CreatedAt),
		UpdatedAt:          timestamppb.New(b.UpdatedAt),
		Title:              b.Title,
		Content:            b.Content,
		Slug:               b.Slug,
		Summary:            b.Summary,
		ExtraData:          b.ExtraData,
		RelevantGroupsID:   relevantGroupsID,
		FollowersID:        followersID,
		CoAuthorsArchiveID: coAuthorsArchiveID,
		Author:             author,
		CoAuthors:          co_authors,
	}, nil
}

func ProtoPostToBiz(p *pb.Post) (*biz.Post, error) {
	if p == nil {
		return nil, nil
	}

	var relevantGroupsID []string
	for _, item := range p.RelevantGroupsID {
		relevantGroupsID = append(relevantGroupsID, item)
	}
	var followers []*biz.User
	for _, item := range p.FollowersID {
		followers = append(followers, &biz.User{UserBase: biz.UserBase{UUID: item}})
	}
	var coAuthorsArchive []*biz.User
	for _, item := range p.CoAuthorsArchiveID {
		coAuthorsArchive = append(coAuthorsArchive, &biz.User{UserBase: biz.UserBase{UUID: item}})
	}
	author, err := ProtoUserToBiz(p.Author)
	if err != nil {
		return nil, err
	}
	var coAuthors []*biz.User
	for _, item := range p.CoAuthors {
		v, err := ProtoUserToBiz(item)
		if err != nil {
			return nil, err
		}
		coAuthors = append(coAuthors, v)
	}
	return &biz.Post{
		PostBase: biz.PostBase{
			UUID:             p.Uuid,
			CreatedAt:        p.CreatedAt.AsTime(),
			UpdatedAt:        p.UpdatedAt.AsTime(),
			Title:            p.Title,
			Content:          p.Content,
			Slug:             p.Slug,
			Summary:          "",
			ExtraData:        p.ExtraData,
			RelevantGroupsID: relevantGroupsID,
			Followers:        followers,
			CoAuthorsArchive: coAuthorsArchive,
			Author:           author,
			CoAuthors:        coAuthors,
		},
	}, nil
}

func ProtoPostInputToBiz(p *pb.PostInput) (*biz.Post, error) {
	if p == nil {
		return nil, nil
	}
	var coAuthors []*biz.User
	for _, item := range p.CoAuthorsID {
		coAuthors = append(coAuthors, &biz.User{UserBase: biz.UserBase{UUID: item}})
	}

	var relevantGroupsID []string
	for _, item := range p.RelevantGroupsID {
		relevantGroupsID = append(relevantGroupsID, item)
	}
	author, err := ProtoUserInputToBiz(p.Author)
	if err != nil {
		return nil, err
	}
	var coAuthorsArchive []*biz.User
	for _, item := range p.CoAuthorsArchive {
		v, err := ProtoUserInputToBiz(item)
		if err != nil {
			return nil, err
		}
		coAuthorsArchive = append(coAuthorsArchive, v)
	}
	return &biz.Post{
		PostBase: biz.PostBase{
			UUID:             p.Uuid,
			CreatedAt:        p.CreatedAt.AsTime(),
			UpdatedAt:        p.UpdatedAt.AsTime(),
			Title:            p.Title,
			Content:          p.Content,
			Slug:             p.Slug,
			ManagementKey:    p.ManagementKey,
			ExtraData:        p.ExtraData,
			CoAuthors:        coAuthors,
			RelevantGroupsID: relevantGroupsID,
			Author:           author,
			CoAuthorsArchive: coAuthorsArchive,
		},
	}, nil
}

func BizUserToProto(b *biz.User) (*pb.User, error) {
	if b == nil {
		return nil, nil
	}

	var postIds []string
	for _, item := range b.PostIDs {
		postIds = append(postIds, item)
	}

	var followersID []string
	for _, item := range b.Followers {
		followersID = append(followersID, item.UUID)
	}

	var coAuthorsArchiveTest []string
	for _, item := range b.CoAuthorsArchive {
		coAuthorsArchiveTest = append(coAuthorsArchiveTest, item.UUID)
	}
	var groups []*pb.Group
	for _, item := range b.Groups {
		v, err := BizGroupToProto(item)
		if err != nil {
			return nil, err
		}
		groups = append(groups, v)
	}
	var friends []*pb.User
	for _, item := range b.Friends {
		v, err := BizUserToProto(item)
		if err != nil {
			return nil, err
		}
		friends = append(friends, v)
	}
	return &pb.User{
		Uuid:                 b.UUID,
		CreatedAt:            timestamppb.New(b.CreatedAt),
		UpdatedAt:            timestamppb.New(b.UpdatedAt),
		Name:                 b.Name,
		Age:                  int32(b.Age),
		Nickname:             b.Nickname,
		UserScore:            uint32(b.UserScore),
		IsVerified:           b.IsVerified,
		Tags:                 b.Tags,
		TestUuid:             b.TestUUID,
		TestNillableUuid:     b.TestNillableUUID,
		Status:               BizUserStatusToProto(b.Status),
		Role:                 string(b.Role),
		RemoteToken:          b.RemoteToken,
		ExtUser:              b.ExtUser,
		TestTime:             b.TestTime.UnixMilli(),
		LastLoginIp:          b.LastLoginIP,
		PostIds:              postIds,
		FollowersID:          followersID,
		CoAuthorsArchiveTest: coAuthorsArchiveTest,
		Groups:               groups,
		Friends:              friends,
	}, nil
}

func ProtoUserToBiz(p *pb.User) (*biz.User, error) {
	if p == nil {
		return nil, nil
	}

	var postIds []string
	for _, item := range p.PostIds {
		postIds = append(postIds, item)
	}
	var followers []*biz.User
	for _, item := range p.FollowersID {
		followers = append(followers, &biz.User{UserBase: biz.UserBase{UUID: item}})
	}
	var coAuthorsArchive []*biz.User
	for _, item := range p.CoAuthorsArchiveTest {
		coAuthorsArchive = append(coAuthorsArchive, &biz.User{UserBase: biz.UserBase{UUID: item}})
	}
	var groups []*biz.Group
	for _, item := range p.Groups {
		v, err := ProtoGroupToBiz(item)
		if err != nil {
			return nil, err
		}
		groups = append(groups, v)
	}
	var friends []*biz.User
	for _, item := range p.Friends {
		v, err := ProtoUserToBiz(item)
		if err != nil {
			return nil, err
		}
		friends = append(friends, v)
	}
	return &biz.User{
		UserBase: biz.UserBase{
			UUID:             p.Uuid,
			CreatedAt:        p.CreatedAt.AsTime(),
			UpdatedAt:        p.UpdatedAt.AsTime(),
			Name:             p.Name,
			Age:              int(p.Age),
			Nickname:         p.Nickname,
			UserScore:        uint8(p.UserScore),
			IsVerified:       p.IsVerified,
			Tags:             p.Tags,
			TestUUID:         p.TestUuid,
			TestNillableUUID: p.TestNillableUuid,
			Status:           ProtoUserStatusToBiz(p.Status),
			Role:             auth.UserRole(p.Role),
			RemoteToken:      p.RemoteToken,
			ExtUser:          p.ExtUser,
			TestTime:         time.UnixMilli(int64(p.TestTime)),
			LastLoginIP:      "",
			PostIDs:          postIds,
			Followers:        followers,
			CoAuthorsArchive: coAuthorsArchive,
			Groups:           groups,
			Friends:          friends,
		},
	}, nil
}

func ProtoUserInputToBiz(p *pb.UserInput) (*biz.User, error) {
	if p == nil {
		return nil, nil
	}

	var postIds []string
	for _, item := range p.PostIds {
		postIds = append(postIds, item)
	}
	var groups []*biz.Group
	for _, item := range p.Groups {
		v, err := ProtoGroupInputToBiz(item)
		if err != nil {
			return nil, err
		}
		groups = append(groups, v)
	}
	var coAuthorsArchive []*biz.User
	for _, item := range p.CoAuthorsArchiveTest {
		v, err := ProtoUserInputToBiz(item)
		if err != nil {
			return nil, err
		}
		coAuthorsArchive = append(coAuthorsArchive, v)
	}
	return &biz.User{
		UserBase: biz.UserBase{
			UUID:             p.Uuid,
			CreatedAt:        p.CreatedAt.AsTime(),
			UpdatedAt:        p.UpdatedAt.AsTime(),
			Name:             p.Name,
			Age:              int(p.Age),
			Nickname:         p.Nickname,
			UserScore:        uint8(p.UserScore),
			IsVerified:       p.IsVerified,
			Tags:             p.Tags,
			Password:         p.Password,
			TestUUID:         p.TestUuid,
			TestNillableUUID: p.TestNillableUuid,
			Status:           ProtoUserStatusToBiz(p.Status),
			Role:             auth.UserRole(p.Role),
			RemoteToken:      p.RemoteToken,
			ExtUser:          p.ExtUser,
			TestTime:         time.UnixMilli(int64(p.TestTime)),
			VerificationCode: p.VerificationCode,
			PostIDs:          postIds,
			Groups:           groups,
			CoAuthorsArchive: coAuthorsArchive,
		},
	}, nil
}

func BizUserStatusToProto(e biz.UserStatus) pb.UserStatus {
	switch e {
	case biz.UserStatusUnspecified:
		return pb.UserStatus_USERSTATUS_UNSPECIFIED
	case biz.UserStatusActive:
		return pb.UserStatus_USERSTATUS_ACTIVE
	case biz.UserStatusInactive:
		return pb.UserStatus_USERSTATUS_INACTIVE
	case biz.UserStatusBanned:
		return pb.UserStatus_USERSTATUS_BANNED
	default:
		return pb.UserStatus_USERSTATUS_UNSPECIFIED
	}
}

func ProtoUserStatusToBiz(e pb.UserStatus) biz.UserStatus {
	switch e {
	case pb.UserStatus_USERSTATUS_UNSPECIFIED:
		return biz.UserStatusUnspecified
	case pb.UserStatus_USERSTATUS_ACTIVE:
		return biz.UserStatusActive
	case pb.UserStatus_USERSTATUS_INACTIVE:
		return biz.UserStatusInactive
	case pb.UserStatus_USERSTATUS_BANNED:
		return biz.UserStatusBanned
	default:
		return biz.UserStatusUnspecified
	}
}
